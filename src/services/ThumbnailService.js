const sharp = require('sharp');
const path = require('path');
const fs = require('fs-extra');
const Database = require('../models/Database');
const ImageWorkerPool = require('../utils/imageWorkerPool');
const logger = require('../utils/logger');

class ThumbnailService {
  constructor() {
    this.db = new Database();
    this.thumbnailDir = path.join(__dirname, '../../public/uploads/thumbnails');
    this.originalDir = path.join(__dirname, '../../public/uploads');
    this.processingQueue = [];
    this.isProcessing = false;
    this.maxRetries = 3;
    this.thumbnailSizes = {
      small: { width: 150, height: 150 },
      medium: { width: 300, height: 300 },
      large: { width: 500, height: 500 }
    };
    
    // üöÄ ÂàùÂßãÂåñWorkerÁ∫øÁ®ãÊ±†
    this.workerPool = new ImageWorkerPool(2); // 2‰∏™WorkerÁ∫øÁ®ã
    
    // Á°Æ‰øùÁº©Áï•ÂõæÁõÆÂΩïÂ≠òÂú®
    this.ensureDirectories();
  }

  async ensureDirectories() {
    try {
      await fs.ensureDir(this.thumbnailDir);
      // ‰∏∫‰∏çÂêåÂ∞∫ÂØ∏ÂàõÂª∫Â≠êÁõÆÂΩï
      for (const size of Object.keys(this.thumbnailSizes)) {
        await fs.ensureDir(path.join(this.thumbnailDir, size));
      }
      console.log('üìÅ Thumbnail directories ensured');
    } catch (error) {
      console.error('Error ensuring thumbnail directories:', error);
    }
  }

  // üöÄ ÁîüÊàêÂçï‰∏™Áº©Áï•Âõæ - ‰ΩøÁî®WorkerÁ∫øÁ®ãÊ±†
  async generateThumbnail(imagePath, outputPath, size = 'medium', quality = 80) {
    try {
      // Ê£ÄÊü•ÂéüÂõæÊòØÂê¶Â≠òÂú®
      if (!(await fs.pathExists(imagePath))) {
        throw new Error(`Original image not found: ${imagePath}`);
      }

      // ‰ΩøÁî®WorkerÁ∫øÁ®ãÊ±†ÁîüÊàêÁº©Áï•Âõæ
      const result = await this.workerPool.generateThumbnail(imagePath, outputPath, size);
      
      logger.performance('Thumbnail generated', {
        imagePath,
        outputPath,
        size,
        outputSize: result.size
      });

      return {
        success: true,
        originalSize: result.dimensions,
        thumbnailSize: result.dimensions,
        outputPath: result.outputPath,
        fileSize: result.size
      };
    } catch (error) {
      logger.error(`Error generating thumbnail for ${imagePath}`, { 
        error: error.message,
        imagePath,
        outputPath,
        size 
      });
      
      return {
        success: false,
        error: error.message
      };
    }
  }

  // ÁîüÊàêÂ§öÁßçÂ∞∫ÂØ∏ÁöÑÁº©Áï•Âõæ
  async generateMultipleThumbnails(imagePath, baseFilename) {
    const results = {};
    
    for (const [sizeName, dimensions] of Object.entries(this.thumbnailSizes)) {
      const outputFilename = `${sizeName}_${baseFilename}`;
      const outputPath = path.join(this.thumbnailDir, sizeName, outputFilename);
      
      results[sizeName] = await this.generateThumbnail(imagePath, outputPath, sizeName);
      results[sizeName].filename = outputFilename;
    }
    
    return results;
  }

  // ÊâπÈáèÁîüÊàêÁº∫Â§±ÁöÑÁº©Áï•Âõæ
  async generateMissingThumbnails() {
    try {
      console.log('üîÑ Starting batch thumbnail generation...');
      
      // Ëé∑ÂèñÊâÄÊúâÊú¨Âú∞ÂõæÁâá
      const images = await this.db.getAllImages();
      const localImages = images.filter(img => img.is_local === 1);
      
      console.log(`üìä Found ${localImages.length} local images to check`);
      
      let generated = 0;
      let failed = 0;
      let skipped = 0;
      
      for (const image of localImages) {
        if (!image.filename) {
          skipped++;
          continue;
        }
        
        const originalPath = path.join(this.originalDir, image.filename);
        
        // Ê£ÄÊü•ÂéüÂõæÊòØÂê¶Â≠òÂú®
        if (!(await fs.pathExists(originalPath))) {
          console.warn(`‚ö†Ô∏è Original image not found: ${image.filename}`);
          failed++;
          continue;
        }
        
        // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÊúâÁº©Áï•Âõæ
        const hasAllThumbnails = await this.checkAllThumbnailsExist(image.filename);
        
        if (hasAllThumbnails) {
          skipped++;
          continue;
        }
        
        // ÁîüÊàêÁº©Áï•Âõæ
        console.log(`üñºÔ∏è Generating thumbnails for: ${image.filename}`);
        const results = await this.generateMultipleThumbnails(originalPath, image.filename);
        
        // Ê£ÄÊü•ÁîüÊàêÁªìÊûú
        const allSuccessful = Object.values(results).every(result => result.success);
        
        if (allSuccessful) {
          generated++;
          
          // Êõ¥Êñ∞Êï∞ÊçÆÂ∫ì‰∏≠ÁöÑÁº©Áï•Âõæ‰ø°ÊÅØ
          await this.updateImageThumbnail(image.id, results.medium.filename);
          
          console.log(`‚úÖ Generated thumbnails for: ${image.filename}`);
        } else {
          failed++;
          console.error(`‚ùå Failed to generate thumbnails for: ${image.filename}`);
        }
        
        // Ê∑ªÂä†Â∞èÂª∂ËøüÈÅøÂÖçËøáÂ∫¶Âç†Áî®CPU
        await this.sleep(100);
      }
      
      const summary = {
        total: localImages.length,
        generated,
        failed,
        skipped,
        timestamp: new Date().toISOString()
      };
      
      console.log('üìã Batch thumbnail generation completed:', summary);
      return summary;
      
    } catch (error) {
      console.error('Error in batch thumbnail generation:', error);
      throw error;
    }
  }

  // Ê£ÄÊü•ÊâÄÊúâÂ∞∫ÂØ∏ÁöÑÁº©Áï•ÂõæÊòØÂê¶Â≠òÂú®
  async checkAllThumbnailsExist(filename) {
    for (const sizeName of Object.keys(this.thumbnailSizes)) {
      const thumbnailPath = path.join(this.thumbnailDir, sizeName, `${sizeName}_${filename}`);
      if (!(await fs.pathExists(thumbnailPath))) {
        return false;
      }
    }
    return true;
  }

  // Êõ¥Êñ∞Êï∞ÊçÆÂ∫ì‰∏≠ÁöÑÁº©Áï•Âõæ‰ø°ÊÅØ
  async updateImageThumbnail(imageId, thumbnailFilename) {
    try {
      // ËøôÈáåÊàë‰ª¨‰ΩøÁî®mediumÂ∞∫ÂØ∏‰Ωú‰∏∫ÈªòËÆ§Áº©Áï•Âõæ
      await this.db.db.run(
        'UPDATE images SET thumbnail = ? WHERE id = ?',
        [`medium_${thumbnailFilename}`, imageId]
      );
    } catch (error) {
      console.error('Error updating thumbnail in database:', error);
    }
  }

  // Ëé∑ÂèñÁº©Áï•ÂõæË∑ØÂæÑ
  getThumbnailPath(filename, size = 'medium') {
    if (!filename) return null;
    
    // Â¶ÇÊûúfilenameÂ∑≤ÁªèÂåÖÂê´Â∞∫ÂØ∏ÂâçÁºÄÔºåÁõ¥Êé•‰ΩøÁî®
    if (filename.startsWith('small_') || filename.startsWith('medium_') || filename.startsWith('large_')) {
      const [sizePrefix, ...rest] = filename.split('_');
      return path.join(this.thumbnailDir, sizePrefix, filename);
    }
    
    // Âê¶ÂàôÊ∑ªÂä†Â∞∫ÂØ∏ÂâçÁºÄ
    const thumbnailFilename = `${size}_${filename}`;
    return path.join(this.thumbnailDir, size, thumbnailFilename);
  }

  // Ê∏ÖÁêÜÂ≠§Á´ãÁöÑÁº©Áï•ÂõæÔºàÂéüÂõæÂ∑≤Âà†Èô§‰ΩÜÁº©Áï•ÂõæËøòÂú®Ôºâ
  async cleanupOrphanedThumbnails() {
    try {
      console.log('üßπ Starting orphaned thumbnail cleanup...');
      
      const images = await this.db.getAllImages();
      const localImageFilenames = new Set(
        images
          .filter(img => img.is_local === 1 && img.filename)
          .map(img => img.filename)
      );
      
      let cleaned = 0;
      
      for (const sizeName of Object.keys(this.thumbnailSizes)) {
        const sizeDir = path.join(this.thumbnailDir, sizeName);
        
        if (await fs.pathExists(sizeDir)) {
          const thumbnailFiles = await fs.readdir(sizeDir);
          
          for (const thumbnailFile of thumbnailFiles) {
            // ÊèêÂèñÂéüÊñá‰ª∂ÂêçÔºàÂéªÊéâÂ∞∫ÂØ∏ÂâçÁºÄÔºâ
            const originalFilename = thumbnailFile.replace(`${sizeName}_`, '');
            
            if (!localImageFilenames.has(originalFilename)) {
              const thumbnailPath = path.join(sizeDir, thumbnailFile);
              await fs.remove(thumbnailPath);
              cleaned++;
              console.log(`üóëÔ∏è Removed orphaned thumbnail: ${thumbnailFile}`);
            }
          }
        }
      }
      
      console.log(`‚úÖ Cleaned up ${cleaned} orphaned thumbnails`);
      return { cleaned };
      
    } catch (error) {
      console.error('Error cleaning up orphaned thumbnails:', error);
      throw error;
    }
  }

  // Ëé∑ÂèñÁº©Áï•ÂõæÁîüÊàêÁªüËÆ°
  async getThumbnailStats() {
    try {
      const images = await this.db.getAllImages();
      const localImages = images.filter(img => img.is_local === 1);
      
      let withThumbnails = 0;
      let withoutThumbnails = 0;
      let totalSizes = {
        small: 0,
        medium: 0,
        large: 0
      };
      
      for (const image of localImages) {
        if (!image.filename) {
          withoutThumbnails++;
          continue;
        }
        
        const hasAllThumbnails = await this.checkAllThumbnailsExist(image.filename);
        
        if (hasAllThumbnails) {
          withThumbnails++;
          
          // ÁªüËÆ°ÂêÑÂ∞∫ÂØ∏Êñá‰ª∂Â§ßÂ∞è
          for (const sizeName of Object.keys(this.thumbnailSizes)) {
            const thumbnailPath = path.join(this.thumbnailDir, sizeName, `${sizeName}_${image.filename}`);
            try {
              const stats = await fs.stat(thumbnailPath);
              totalSizes[sizeName] += stats.size;
            } catch (error) {
              // ÂøΩÁï•Êñá‰ª∂‰∏çÂ≠òÂú®ÁöÑÈîôËØØ
            }
          }
        } else {
          withoutThumbnails++;
        }
      }
      
      return {
        total: localImages.length,
        withThumbnails,
        withoutThumbnails,
        coverage: localImages.length > 0 ? (withThumbnails / localImages.length * 100).toFixed(2) : 0,
        totalSizes,
        timestamp: new Date().toISOString()
      };
      
    } catch (error) {
      console.error('Error getting thumbnail stats:', error);
      throw error;
    }
  }

  // ÂºÇÊ≠•Â§ÑÁêÜÈòüÂàó
  async addToQueue(imagePath, filename, priority = 'normal') {
    this.processingQueue.push({
      imagePath,
      filename,
      priority,
      retries: 0,
      addedAt: Date.now()
    });
    
    if (!this.isProcessing) {
      this.processQueue();
    }
  }

  async processQueue() {
    if (this.isProcessing || this.processingQueue.length === 0) {
      return;
    }
    
    this.isProcessing = true;
    console.log(`üîÑ Processing thumbnail queue (${this.processingQueue.length} items)`);
    
    while (this.processingQueue.length > 0) {
      // Êåâ‰ºòÂÖàÁ∫ßÊéíÂ∫è
      this.processingQueue.sort((a, b) => {
        const priorityOrder = { high: 3, normal: 2, low: 1 };
        return priorityOrder[b.priority] - priorityOrder[a.priority];
      });
      
      const item = this.processingQueue.shift();
      
      try {
        const results = await this.generateMultipleThumbnails(item.imagePath, item.filename);
        const allSuccessful = Object.values(results).every(result => result.success);
        
        if (allSuccessful) {
          console.log(`‚úÖ Queue: Generated thumbnails for ${item.filename}`);
        } else {
          throw new Error('Some thumbnails failed to generate');
        }
        
      } catch (error) {
        item.retries++;
        
        if (item.retries < this.maxRetries) {
          console.warn(`‚ö†Ô∏è Queue: Retrying ${item.filename} (attempt ${item.retries + 1})`);
          this.processingQueue.push(item);
        } else {
          console.error(`‚ùå Queue: Failed to generate thumbnails for ${item.filename} after ${this.maxRetries} attempts`);
        }
      }
      
      // Ê∑ªÂä†Â∞èÂª∂Ëøü
      await this.sleep(50);
    }
    
    this.isProcessing = false;
    console.log('‚úÖ Thumbnail queue processing completed');
  }

  // ‰øÆÂ§çÊçüÂùèÁöÑÁº©Áï•Âõæ
  async repairCorruptedThumbnails() {
    try {
      console.log('üîß Starting corrupted thumbnail repair...');
      
      let repaired = 0;
      
      for (const sizeName of Object.keys(this.thumbnailSizes)) {
        const sizeDir = path.join(this.thumbnailDir, sizeName);
        
        if (await fs.pathExists(sizeDir)) {
          const thumbnailFiles = await fs.readdir(sizeDir);
          
          for (const thumbnailFile of thumbnailFiles) {
            const thumbnailPath = path.join(sizeDir, thumbnailFile);
            
            try {
              // Â∞ùËØïËØªÂèñÂõæÁâáÂÖÉÊï∞ÊçÆÊù•Ê£ÄÊü•ÊòØÂê¶ÊçüÂùè
              await sharp(thumbnailPath).metadata();
            } catch (error) {
              console.log(`üîß Repairing corrupted thumbnail: ${thumbnailFile}`);
              
              // Âà†Èô§ÊçüÂùèÁöÑÁº©Áï•Âõæ
              await fs.remove(thumbnailPath);
              
              // ÈáçÊñ∞ÁîüÊàê
              const originalFilename = thumbnailFile.replace(`${sizeName}_`, '');
              const originalPath = path.join(this.originalDir, originalFilename);
              
              if (await fs.pathExists(originalPath)) {
                const result = await this.generateThumbnail(originalPath, thumbnailPath, sizeName);
                if (result.success) {
                  repaired++;
                  console.log(`‚úÖ Repaired: ${thumbnailFile}`);
                }
              }
            }
          }
        }
      }
      
      console.log(`üîß Repaired ${repaired} corrupted thumbnails`);
      return { repaired };
      
    } catch (error) {
      console.error('Error repairing corrupted thumbnails:', error);
      throw error;
    }
  }

  // Â∑•ÂÖ∑ÂáΩÊï∞
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

module.exports = ThumbnailService;